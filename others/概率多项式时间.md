# 概率多项式时间

一般说的多项式时间算法指的是确定性多项式时间算法，确定性指的是如果对于两次解决同一个问题，得到的答案是相同的，那么就叫做确定性。否则叫做概率性。

## 随机算法：一个例子

我们给出一个简单的随机算法来判断一个给定的（无向）图是否连通（也就是说，图中每一对顶点之间都存在一条通路）。它使用的空间比标准的（基于BFS或DFS）确定性算法要少得多。

测试一个图是否连通可以归结为测试任意给定的一对顶点之间的连通性。

> 这种归约的空间复杂度较低；我们只需要存储两个顶点（目前正在测试）的名字。遗憾的是，时间复杂度确实比较高；需要调用双测试顶点$C^2_n$次，其中$n$为图中顶点的个数。

**算法**：在输入一个图$G=(V,E)$和两个顶点$s$和$t$的情况下，我们从顶点$s$开始进行长度为$O ( | V | · | E | )$的随机游走，并在每一步测试是否遇到顶点$t$。如果曾经遇到过顶点$t$，那么算法就会接受；否则，它将被拒绝。通过随机游走，我们意味着在每一步中，我们均匀地选择一条与当前顶点相关联的边，并将这条边遍历到另一个端点。

**分析**：显然，如果$s$与$t$在图G中不连通，则上述算法接受的概率为零。分析的难点是证明如果$s$与$t$在图G中连通，那么算法将以至少$2/3$的概率接受。因此，无论哪种方式，算法的错误（不接受）概率至多为$1/3$。通过多次调用（在每次尝试中使用新鲜的随机选择）算法，可以进一步降低错误概率。

## 随机算法：两个视角

可以用两种等价的方式来看待随机算法（机器）。

观察随机算法的一种方法是让算法做随机移动（即“抛掷硬币”）。从形式上讲，这可以通过一个图灵机来建模，其中转换函数将$(〈状态〉,〈符号〉)$映射到两个可能的三元组$(〈状态〉,〈符号〉,〈方向〉)$。这样的机器的下一步是通过随机选择其中一个三元组来决定的。也就是说，为了迈出一步，机器随机选择中的一个三元组（对于每一种可能概率为$1/2$），然后执行相应的动作。这些随机选择被称为机器的内部抛掷硬币（internal coin tosses）。概率机器$M$在输入$x$上的输出不是一个串，而是一个假定串为可能值的随机变量（满足均匀分布）。这个随机变量，记为$M(x)$，是由$M$的内部抛掷硬币引起的。用$\operatorname{Pr}[M(x)=y]$表示机器$M$在输入$x$上输出$y$的概率。由于我们只考虑多项式时间的机器，不失一般性，我们可以假设$M$在输入$x$上掷硬币的次数（记为$t_M ( x )$）与它们的结果无关。我们用$M_r ( x )$表示$M$在输入$x$上的输出，其中$r$是$M$内部抛硬币的结果。则：
$$
\operatorname{Pr}[M(x)=y]=\frac{\left|\left\{r \in\{0,1\}^{t_M(x)}: M_r(x)=y\right\}\right|}{2^{t_M(x)}}
$$
等式右边的意思是$M$内部掷币$t_M ( x )$次一共有$2^{t_M(x)}$种情况，其中使得$M$输出$y$的情况所对应的掷币结果为$r \in\{0,1\}^{t_M(x)}: M_r(x)=y$，共有$\left|\left\{r \in\{0,1\}^{t_M(x)}: M_r(x)=y\right\}\right|$种。

观察随机算法的第二种方法是将机器内部掷币结果作为辅助输入。也就是说，我们考虑具有两个输入的确定性机器。那么$M(x,r)$对应于上一种视角中的$M_r(x)$。在$M(x,r)$中$x$是固定的，$r$是均匀随机选择的序列$r \in\{0,1\}^{t_M(x)}$。这里的掷硬币不是“内部”的，而是由“外部”的掷币设备提供给机器的。

> 这里注意不要把非确定（non-deterministic）机器和概率机器混为一谈，非确定机器是指（在讨论P和NP问题中）可以解决NP问题的不现实的模型，而后者是一个现实的计算模型。

概率多项式时间图灵机（probabilistic polynomial-time Turing machine）是指在关于输入长度的多项式步数之后总会（即独立于其内部抛掷硬币的结果）停机的概率机器。由此可知，概率多项式时间机器$M$的掷硬币次数在其输入长度上以多项式$T_M$为界。最后，不失一般性，我们假设机器在输入$x$处总是抛$T_M ( | x | )$​​次硬币。

> 停机可以通俗理解为总有输出结果/解决了问题。

## BPP

这里，我们将考虑作为有效的唯一随机算法（即概率图灵机），其运行时间是关于输入长度的多项式。

**定义：有界概率多项式时间（Bounded-Probability Polynomial Time，BPP）**：对于语言$L$，如果存在一个概率多项式时间图灵机$M$使得

- 对于每个$x\in L$有$\operatorname{Pr}[M(x)=1] \geq \frac{2}{3}$，并且
- 对于每个$x\notin L$有$\operatorname{Pr}[M(x)=0] \geq \frac{2}{3}$。

我们就称$L$是一个概率多项式时间可识别的语言。所有概率多项式时间可识别的语言组成语言类BPP。

BPP是一类可以被概率多项式时间图灵机（即随机算法）识别的语言。

> 简言之，BPP问题是一类在多项式时间里被概率图灵机解出的问题，并且对所有的输入，输出结果有错误的概率在$1/3$之内（实际上错误概率小于$1/2$即可）。

“有界概率”（bounded-probability）一词表示成功概率远高于$1/2$。事实上，在上述定义中，将常数$2/3$替换为任何大于$1/2$的其他常数都不会改变所定义的复杂度类。原因在于，虽然这算法有错误的几率，但是只要多重复几次算法，那多数的答案都是错误的几率会呈现指数衰减。因此我们得出结论，BPP类问题可以通过概率多项式时间算法解决，并且具有可忽略的错误概率。我们用可忽略不计来描述比任何多项式的倒数下降得更快的函数：

**可忽略函数（Negligible Functions）**

**定义：可忽略的（Negligible）**：我们说一个函数$\mu: \mathbb{N} \rightarrow \mathbb{R}$是可忽略的，如果对于每个正多项式$p(\cdot)$存在一个$N$使得对于所有的$n>N$，
$$
\mu(n)<\frac{1}{p(n)}
$$
例如，函数$2^{-\sqrt{n}}$和$n^{-\log _2 n}$是可忽略的。可忽略不计的函数乘以任意固定多项式仍然是可忽略的。因此，即使我们重复实验多项式次数，以可忽略不计的概率发生的事件也不会发生。

**惯例**。在上述定义中，我们使用短语“存在一个$N$使得对所有的$n > N$”，今后我们将使用更短且不太繁琐的陈述“对所有足够大的$n$”。这样可以省略量词$\exists N$​，利于描述包含几个量词的语句。

**结论**：高效的计算对应于概率多项式时间图灵机可以进行的计算。换言之，如果一个问题是BPP类问题，那么意味着它可以被高效解决。

> 一些地方将BPP写作Bounded-error Probabilistic Polynomial time，指错误概率是有限的。



## BPP与其他复杂度类的关系

BPP与P唯一不同的是，BPP的算法允许包含随机决策的步骤，BPP的算法只需要以接近1的概率给出正确答案即可，因此可以将P理解为BPP的特例。**显然，P$\subseteq$BPP，因为P便是不需抛硬币、输出结果确定的BPP**。而现在很多科学家认为，**P可能等于BPP，这是又一个开放性问题**。有趣的是，我们甚至还不知道BPP与NP的关系，而只知道BPP$\subseteq$PSPACE。



> 参考资料：
>
> 1. Foundations of cryptography. 1: Basic tools
> 2. https://zh.wikipedia.org/wiki/BPP_(%E8%A4%87%E9%9B%9C%E5%BA%A6)
> 3. https://www.cnblogs.com/zhangzefei/p/9734834.html
> 4. https://en.wikipedia.org/wiki/PP_(complexity)